-- 多线程编程的优势和存在的风险
  |-- 多线程编程具有以下优势：
    (1) 提高系统的吞吐率(Throughput rate),多线程编程可以使一个进程有多个并发(concurrent,即同时进行)操作
    (2) 提高响应性(Responsiveness),Web服务器会采用一些专门的线程负责用户的请求处理,缩短了用户的等待时间
    (3) 充分利用多核(Multi-core)处理器资源,通过多线程可以充分的利用CPU资源

  |-- 多线程编程存在的问题和风险
    (1) 线程安全(Thread safe)问题，多线程共享数据时，如果没有采取正确的并发访问控制措施,
        就可能产生数据一致性问题,如读取脏数据(过期的数据),如丢失数据更新
    (2) 线程活性问题(Thread active)问题,由于程序自身的缺陷或者由资源稀缺性导致线程一直处于非RUNNABLE状态,
        这就是线程活性问题.常见的活性故障有以下几种：
        <1> 死锁(Deadlock)
        <2> 锁死(Lockout):类似于睡美人,
        <3> 活锁(Livelock):类似于猫咬自己尾巴，就是咬不到
        <4> 饥饿(Starvation):类似于健壮的雏鸟总是从母鸟中抢到食物
    (3) 上下文切换(Context Switch)问题,处理器从执行一个线程切换到执行另外一个线程
    (4) 可靠性问题,可能会有一个线程导致java虚拟机终止，其他线程也无法执行

-- 线程安全问题
  非线程安全主要是指多个线程对同一个对象的实例变量进行操作时，会出现值被更改，值不同步的情况
  线程安全问题主要表现在三个方面：原子性、可见性和有序性
  |-- 原子性
    原子(Atomic)就是不可分割的意思,原子操作的不可分割有两层含义：
        1) 访问(读、写)某个共享变量的操作在其他线程看来，该操作要么已经执行完毕了，要么尚未发生，
            即其他线程不能看到当前线程的中间过程
        2) 访问同一组共享变量的原子操作是不能够交错的
            java有两种方式实现原子性：一种是使用锁；另一种是利用处理器的CAS(Compare and Swap)指令
            锁具有排他性,保证共享变量在某一时刻只能被一个线程访问
            CAS指令:直接在硬件(处理器和内存)层次上实现,看作是硬件锁

  |-- 可见性 (visibility)
    在多线程环境中，一个线程对某个共享变量进行更新之后，后续其他的线程可能无法立即读取到这个更新的结果

  |-- 有序性 (Ordering)
    有序性是指在什么情况下一个处理器上运行的一个线程所执行的，内存访问操作在另一个处理器运行的其他线程看来是乱序的(Out Of Order)
    乱序是指内存访问操作的顺序看起来发生了变化

    |-- 重排序
    在多核处理器的环境下，编写的顺序结构，这种操作执行的顺序可能是没有保障的:
        编译器可能会改变两个操作的先后顺序;
        处理器也可能不会按照目标代码顺序执行;
        这种一个处理器上执行的多个操作，在其他处理器来看，它的执行顺序与目标代码指定的顺序可能不一样，
    这种现象称为重排序。
        重排序是对内存访问有关操作的一种优化，可以在不影响单线程程序正确的情况下，提升程序的性能。但是，
    可能对多线程的正确性产生影响，即可能导致线程安全问题。
        重排序与可见性问题类似，不是必然出现的.
    与内存操作顺序有关的几个概念：
        源代码顺序:就是源码中指定的内存访问顺序
        程序顺序:处理器上运行的目标代码所指定的内存访问顺序
        执行顺序:内存访问操作在处理器上的实际执行顺序
        感知顺序:给定处理器所感知到该处理器及其处理器内存访问操作的顺序

    可以把重排序分为指令重排序与存储子系统重排序两种:
        指令重排序主要是由JIT编译器、处理器引起的，指程序顺序与执行顺序不一样
        存储子系统重排序是由高速缓存、写缓冲器引起的，感知顺序与执行顺序不一致

    |-- 指令重排序
      在源码顺序与程序顺序不一致，或者程序顺序和执行顺序不一致的情况下，我们就说发生了
    指令重排序(Instruction Reorder)
      指令重排是一种动作，确实对执行的顺序做了调整重排序的对象是指令。
      javac编译器一般不会执行指令重排序，而JIT编译器可能执行指令重排序。
      处理器也可能执行指令重排序，使得执行顺序与程序顺序不一致。
      指令重排序不会对单线程程序结果准确性产生影响，可能导致多线程程序出现非预期结果。

    |-- 存储子系统重排序
      存储子系统是指写缓冲器与高速缓存。
      高速缓存(Cache)是CPU中为了匹配与主内存处理速度不匹配而设计的一个高速缓存。
      写缓冲器(Store buffer, Write buffer)用来提高写高速缓存操作的效率。
      即使处理器严格按照程序顺序执行俩个内存操作，在存储子系统的作用下，其他处理器对这两个操作的
    感知顺序与程序顺序不一致，即这两个操作的执行顺序看起来像是发生了变化，这种想象称为存储子系统重排序。
      存储子系统重排序并没有真正的对指令执行顺序进行调整，而是造成一种执行顺序被调整的现象。
      存储子系统重排序对象是内存操作的结果。

      从处理器角度来看，读内存就是从指定的RAM地址中加载数据到寄存器，称为Load操作；写内存就是把数据存储
    到指定的地址表示的RAM存储单元中，称为Store操作。内存重排序有一下四种可能：
        LoadLoad重排序：一个处理器先后执行两个读操作L1和L2，其他处理器对两个内存操作的繁殖顺序可能是L2->L1
        StoreStore重排序：一个处理器先后执行两个读操作W1和W2，其他处理器对两个内存操作的繁殖顺序可能是W2->W1
        LoadStore重排序：一个处理先执行读内存操作L1，再执行写内存操作W1，其他处理器对两个内存操作的
    感知顺序可能是W1->L1;
        StoreLoad重排序：一个处理器先执行写内存操作W1，再执行读内存操作L1，其他处理器对两个内存操作的
    感知顺序可能是L1->W1
      内存重排序与具体的处理器微架构有关，不同架构的处理器所允许的内存重排序不同。
      内存重排序可能会导致线程安全问题。
    |-- 貌似串行语句
      JIT编译器、处理器，存储子系统是按照一定的规则对执行、内存操作的结果进行重排序，给单线程程序造成
    一种假象--指令是按照源码的顺序执行的。这种假象称为貌似串行语义。并不能保证多线程环境下程序的准确性。
      为了保证貌似串行语义，有数据依赖关系的语句不会被重排序，只有不存在数据依赖关系的语句才会被从排序。
    如果两个操作(指令)访问同一个变量，且其中一个操作(指令)为写操作，那么这两个操作之间就存在数据依赖关系(Data dependency)。

    存在控制依赖关系的语句允许重拍，一条语句(指令)的执行结果会决定另一条语句(指令)能否被执行，这两条语句(指令)存在
  控制依赖关系(Control Dependency)。如在if语句中允许重排，可能存在处理器先执行if代码块，在判断if条件是否成立。

    |-- 保证内存访问的顺序性
      可以使用volatile关键字、synchronized关键字实现有序性

  |-- java内存模型
    <1> 每个线程都有独立的栈空间
    <2> 每个线程都可以访问堆空间
    <3> 计算机的CPU不直接从主内存中读取数据，CPU读取数据时，先把主内存的数据读到Cache缓存中，
  把Cache中的数据读到Register寄存器中。
    <4> JVM中的共享的数据可能会被分配到Register寄存器中，每个CPU都有自己的Register寄存器，
  一个CPU不能读取其他CPU上寄存器中的内容，
  如果两个线程分别运行在不同的处理器(CPU)，而这个共享的数据被分配到寄存器上，会产生可见性问题、
    <5> 即使JVM的共享数据分配到主内存中，也不能保证数据的可见性。CPU不直接对主内存访问，而是通过Cache高速缓存
  进行的。一个处理器上运行的线程对数据的更新可能只是更新到处理器的写缓冲器(Store Buffer)，还没有到达Cache缓存，
  更不用说主内存了。另外一个处理器不能读取到该处理器写缓冲器上的内容，会产生运行在另外一个处理器上的线程无法看到该
  处理器对共享数据的更新。
    <6> 一个处理器的Cache不能直接读取另外一个处理器的Cache，但是一个处理器可以通过缓存一直协议(Cache Coherence Protocol）
  来读取其他处理器缓存中的数据，并将读取的数据更新到该处理器的Cache中