-- 多线程编程的优势和存在的风险
  |-- 多线程编程具有以下优势：
    (1) 提高系统的吞吐率(Throughput rate),多线程编程可以使一个进程有多个并发(concurrent,即同时进行)操作
    (2) 提高响应性(Responsiveness),Web服务器会采用一些专门的线程负责用户的请求处理,缩短了用户的等待时间
    (3) 充分利用多核(Multi-core)处理器资源,通过多线程可以充分的利用CPU资源

  |-- 多线程编程存在的问题和风险
    (1) 线程安全(Thread safe)问题，多线程共享数据时，如果没有采取正确的并发访问控制措施,
        就可能产生数据一致性问题,如读取脏数据(过期的数据),如丢失数据更新
    (2) 线程活性问题(Thread active)问题,由于程序自身的缺陷或者由资源稀缺性导致线程一直处于非RUNNABLE状态,
        这就是线程活性问题.常见的活性故障有以下几种：
        <1> 死锁(Deadlock)
        <2> 锁死(Lockout):类似于睡美人,
        <3> 活锁(Livelock):类似于猫咬自己尾巴，就是咬不到
        <4> 饥饿(Starvation):类似于健壮的雏鸟总是从母鸟中抢到食物
    (3) 上下文切换(Context Switch)问题,处理器从执行一个线程切换到执行另外一个线程
    (4) 可靠性问题,可能会有一个线程导致java虚拟机终止，其他线程也无法执行

-- 线程安全问题
  非线程安全主要是指多个线程对同一个对象的实例变量进行操作时，会出现值被更改，值不同步的情况
  线程安全问题主要表现在三个方面：原子性、可见性和有序性
  |-- 原子性
    原子(Atomic)就是不可分割的意思,原子操作的不可分割有两层含义：
        1) 访问(读、写)某个共享变量的操作在其他线程看来，该操作要么已经执行完毕了，要么尚未发生，
            即其他线程不能看到当前线程的中间过程
        2) 访问同一组共享变量的原子操作是不能够交错的
            java有两种方式实现原子性：一种是使用锁；另一种是利用处理器的CAS(Compare and Swap)指令
            锁具有排他性,保证共享变量在某一时刻只能被一个线程访问
            CAS指令:直接在硬件(处理器和内存)层次上实现,看作是硬件锁

  |-- 可见性 (visibility)
    在多线程环境中，一个线程对某个共享变量进行更新之后，后续其他的线程可能无法立即读取到这个更新的结果

  |-- 有序性 (Ordering)
    有序性是指在什么情况下一个处理器上运行的一个线程所执行的，内存访问操作在另一个处理器运行的其他线程看来是乱序的(Out Of Order)
    乱序是指内存访问操作的顺序看起来发生了变化

    |-- 重排序
    在多核处理器的环境下，编写的顺序结构，这种操作执行的顺序可能是没有保障的:
        编译器可能会改变两个操作的先后顺序;
        处理器也可能不会按照目标代码顺序执行;
        这种一个处理器上执行的多个操作，在其他处理器来看，它的执行顺序与目标代码指定的顺序可能不一样，
    这种现象称为重排序。
        重排序是对内存访问有关操作的一种优化，可以在不影响单线程程序正确的情况下，提升程序的性能。但是，
    可能对多线程的正确性产生影响，即可能导致线程安全问题。
        重排序与可见性问题类似，不是必然出现的.
    与内存操作顺序有关的几个概念：
        源代码顺序:就是源码中指定的内存访问顺序
        程序顺序:处理器上运行的目标代码所指定的内存访问顺序
        执行顺序:内存访问操作在处理器上的实际执行顺序
        感知顺序:给定处理器所感知到该处理器及其处理器内存访问操作的顺序

    可以把重排序分为指令重排序与存储子系统重排序两种:
        指令重排序主要是由JIT编译器、处理器引起的，指程序顺序与执行顺序不一样
        存储子系统重排序是由高速缓存、写缓冲器引起的，感知顺序与执行顺序不一致

    |-- 指令重排序
      在源码顺序与程序顺序不一致，或者程序顺序和执行顺序不一致的情况下，我们就说发生了
    指令重排序(Instruction Reorder)
      指令重排是一种动作，确实对执行的顺序做了调整重排序的对象是指令。
      javac编译器一般不会执行指令重排序，而JIT编译器可能执行指令重排序。
      处理器也可能执行指令重排序，使得执行顺序与程序顺序不一致。
      指令重排序不会对单线程程序结果准确性产生影响，可能导致多线程程序出现非预期结果。

    |-- 存储子系统重排序
      存储子系统是指写缓冲器与高速缓存。
      高速缓存(Cache)是CPU中为了匹配与主内存处理速度不匹配而设计的一个高速缓存。
      写缓冲器(Store buffer, Write buffer)用来提高写高速缓存操作的效率。
      即使处理器严格按照程序顺序执行俩个内存操作，在存储子系统的作用下，其他处理器对这两个操作的
    感知顺序与程序顺序不一致，即这两个操作的执行顺序看起来像是发生了变化，这种想象称为存储子系统重排序。
      存储子系统重排序并没有真正的对指令执行顺序进行调整，而是造成一种执行顺序被调整的现象。
      存储子系统重排序对象是内存操作的结果。

      从处理器角度来看，读内存就是从指定的RAM地址中加载数据到寄存器，称为Load操作；写内存就是把数据存储
    到指定的地址表示的RAM存储单元中，称为Store操作。内存重排序有一下四种可能：
        LoadLoad重排序：一个处理器先后执行两个读操作L1和L2，其他处理器对两个内存操作的繁殖顺序可能是L2->L1
        StoreStore重排序：一个处理器先后执行两个读操作W1和W2，其他处理器对两个内存操作的繁殖顺序可能是W2->W1
        LoadStore重排序：一个处理先执行读内存操作L1，再执行写内存操作W1，其他处理器对两个内存操作的
    感知顺序可能是W1->L1;
        StoreLoad重排序：一个处理器先执行写内存操作W1，再执行读内存操作L1，其他处理器对两个内存操作的
    感知顺序可能是L1->W1
      内存重排序与具体的处理器微架构有关，不同架构的处理器所允许的内存重排序不同。
      内存重排序可能会导致线程安全问题。
    |-- 貌似串行语句
      JIT编译器、处理器，存储子系统是按照一定的规则对执行、内存操作的结果进行重排序，给单线程程序造成
    一种假象--指令是按照源码的顺序执行的。这种假象称为貌似串行语义。并不能保证多线程环境下程序的准确性。
      为了保证貌似串行语义，有数据依赖关系的语句不会被重排序，只有不存在数据依赖关系的语句才会被从排序。
    如果两个操作(指令)访问同一个变量，且其中一个操作(指令)为写操作，那么这两个操作之间就存在数据依赖关系(Data dependency)。

  |-- java内存模型