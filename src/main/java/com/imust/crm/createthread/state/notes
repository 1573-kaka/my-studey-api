-- 多线程编程的优势和存在的风险
  |-- 多线程编程具有以下优势：
    (1) 提高系统的吞吐率(Throughput rate),多线程编程可以使一个进程有多个并发(concurrent,即同时进行)操作
    (2) 提高响应性(Responsiveness),Web服务器会采用一些专门的线程负责用户的请求处理,缩短了用户的等待时间
    (3) 充分利用多核(Multi-core)处理器资源,通过多线程可以充分的利用CPU资源

  |-- 多线程编程存在的问题和风险
    (1) 线程安全(Thread safe)问题，多线程共享数据时，如果没有采取正确的并发访问控制措施,
        就可能产生数据一致性问题,如读取脏数据(过期的数据),如丢失数据更新
    (2) 线程活性问题(Thread active)问题,由于程序自身的缺陷或者由资源稀缺性导致线程一直处于非RUNNABLE状态,
        这就是线程活性问题.常见的活性故障有以下几种：
        <1> 死锁(Deadlock)
        <2> 锁死(Lockout):类似于睡美人,
        <3> 活锁(Livelock):类似于猫咬自己尾巴，就是咬不到
        <4> 饥饿(Starvation):类似于健壮的雏鸟总是从母鸟中抢到食物
    (3) 上下文切换(Context Switch)问题,处理器从执行一个线程切换到执行另外一个线程
    (4) 可靠性问题,可能会有一个线程导致java虚拟机终止，其他线程也无法执行

-- 线程安全问题
  非线程安全主要是指多个线程对同一个对象的实例变量进行操作时，会出现值被更改，值不同步的情况
  线程安全问题主要表现在三个方面：原子性、可见性和有序性
  |-- 原子性
    原子(Atomic)就是不可分割的意思,原子操作的不可分割有两层含义：
        1) 访问(读、写)某个共享变量的操作在其他线程看来，该操作要么已经执行完毕了，要么尚未发生，
            即其他线程不能看到当前线程的中间过程
        2) 访问同一组共享变量的原子操作是不能够交错的
            java有两种方式实现原子性：一种是使用锁；另一种是利用处理器的CAS(Compare and Swap)指令
            锁具有排他性,保证共享变量在某一时刻只能被一个线程访问
            CAS指令:直接在硬件(处理器和内存)层次上实现,看作是硬件锁

  |-- 可见性 (visibility)
    在多线程环境中，一个线程对某个共享变量进行更新之后，后续其他的线程可能无法立即读取到这个更新的结果

  |-- 有序性 (Ordering)
    有序性是指在什么情况下一个处理器上运行的一个线程所执行的，内存访问操作在另一个处理器运行的其他线程看来是乱序的(Out Of Order)
    乱序是指内存访问操作的顺序看起来发生了变化

    |-- 重排序
    在多核处理器的环境下，编写的顺序结构，这种操作执行的顺序可能是没有保障的:
        编译器可能会改变两个操作的先后顺序;
        处理器也可能不会按照目标代码顺序执行;
        这种一个处理器上执行的多个操作，在其他处理器来看，它的执行顺序与目标代码指定的顺序可能不一样，
    这种现象称为重排序。
        重排序是对内存访问有关操作的一种优化，可以在不影响单线程程序正确的情况下，提升程序的性能。但是，
    可能对多线程的正确性产生影响，即可能导致线程安全问题。
        重排序与可见性问题类似，不是必然出现的.
    与内存操作顺序有关的几个概念：
        源代码顺序:就是源码中指定的内存访问顺序
        程序顺序:处理器上运行的目标代码所指定的内存访问顺序
        执行顺序:内存访问操作在处理器上的实际执行顺序
        感知顺序:给定处理器所感知到该处理器及其处理器内存访问操作的顺序

    可以把重排序分为指令重排序与存储子系统重排序两种:
        指令重排序主要是由JIT编译器、处理器引起的，指程序顺序与执行顺序不一样
        存储子系统重排序是由高速缓存、写缓冲器引起的，感知顺序与执行顺序不一致

    |-- 指令重排序
      在源码顺序与程序顺序不一致，或者程序顺序和执行顺序不一致的情况下，我们就说发生了指令重排序(Instruction Reorder)
      指令重排是一种动作，确实对执行的顺序做了调整重排序的对象是指令

    |-- 存储子系统重排序


  |-- java内存模型